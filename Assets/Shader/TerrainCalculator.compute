// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> Constraintsmap;
float4 features[512];
int features_count;
float4 constraints[512];
int constraints_count;
//float height_base;
float x;
float z;
float resolution;
float bias_y;
RWStructuredBuffer<int> progress;
//RWStructuredBuffer<float> heights;

float getWeight(float d, float w)
{
    float f = pow(d, w);
    if (f < 0.000001)
        return 0.000001;
    return 1 / f;
}

float NNI(float x, float z)
{
    float dist_min = 1e6;
    float min_index = 0;
    for (int i = 0; i < features_count; i++)
    {
        float dist = sqrt(pow(features[i].x - x, 2) + pow(features[i].z - z, 2));
        if (features[i].w > -1 && dist < dist_min)
        {
            dist_min = dist;
            min_index = i;
        }
    }
    return features[min_index].y;
}

float linearWeight(float x, float z)
{
    float dist_min = 1e6;
    float min_index = 0;
    for (int i = 0; i < constraints_count; i++)
    {
        float dist = sqrt(pow(constraints[i].x - x, 2) + pow(constraints[i].z - z, 2));
        if (dist < dist_min)
        {
            dist_min = dist;
            min_index = i;
        }
    }
    
    if (min_index < constraints_count - 1)
    {
        float2 AB = float2(constraints[min_index + 1].x - constraints[min_index].x, constraints[min_index + 1].z - constraints[min_index].z);
        float2 AC = float2(x - constraints[min_index].x, z - constraints[min_index].z);
        float AB_AC = (AB.x * AC.x + AB.y * AC.y);
        if (AB_AC > 0)
        {
            float dist_a = sqrt(pow(constraints[min_index].x - x, 2) + pow(constraints[min_index].z - z, 2));
            float dist_b = sqrt(pow(constraints[min_index + 1].x - x, 2) + pow(constraints[min_index + 1].z - z, 2));
            return (constraints[min_index].y * dist_b + constraints[min_index + 1].y * dist_a) / (dist_a + dist_b);
        }
        else
        {
            if (min_index > 0)
            {
                float dist_a = sqrt(pow(constraints[min_index - 1].x - x, 2) + pow(constraints[min_index - 1].z - z, 2));
                float dist_b = sqrt(pow(constraints[min_index].x - x, 2) + pow(constraints[min_index].z - z, 2));
                return (constraints[min_index - 1].y * dist_b + constraints[min_index].y * dist_a) / (dist_a + dist_b);
            }
            else
            {
                return constraints[min_index].y;
            }
        }
    }
    else
    {
        return constraints[min_index].y;
    }
}

float IDW(float x, float z)
{
    float sum_up = 0.0;
    float sum_down = 0.0;
    for (int i = 0; i < features_count; i++)
    {
        if (features[i].w > -1)
            continue;
        float dist = sqrt(pow(features[i].x - x, 2) + pow(features[i].z - z, 2));
        if (pow(dist, 2) < 1e-6)
            return features[i].y;
        if (dist < 320.0) // TerrainGenerator.feature_include_length = 320.0f
        {
            sum_up += getWeight(dist, 2) * features[i].y;
            sum_down += getWeight(dist, 2);
        }
    }
    if (sum_down < 1e-6)
        sum_down = 1e-6;
    return sum_up / sum_down;
}

float roadConstraint(float x, float z)
{
    for (int i = 0; i < constraints_count - 1; i++)
    {
        float2 AB = float2(constraints[i + 1].x - constraints[i].x, constraints[i + 1].z - constraints[i].z);
        float2 AC = float2(x - constraints[i].x, z - constraints[i].z);
        float2 BC = float2(x - constraints[i + 1].x, z - constraints[i + 1].z);

        float AB_BC = (AB.x * BC.x + AB.y * BC.y);
        float AB_AC = (AB.x * AC.x + AB.y * AC.y);

        float distance = 1e6;

        if (AB_BC < 0 && AB_AC > 0)
        {
            // Finding the perpendicular distance
            float x1 = AB.x;
            float y1 = AB.y;
            float x2 = AC.x;
            float y2 = AC.y;
            float mod = sqrt(x1 * x1 + y1 * y1);
            distance = abs(x1 * y2 - y1 * x2) / mod;
        }

        if (distance < 4.0f)
        {
            return (i + 1) / 20.0;
        }
    }
    for (int i = 0; i < constraints_count; i++)
    {
        float dist = sqrt(pow(constraints[i].x - x, 2) + pow(constraints[i].z - z, 2));
        if (dist < 4.0f)
        {
            return (i + 1) / 20.0;
        }
    }
    return 0.0f;
}

float2 renderConstraints(float x, float z)
{
    // float xCoord = x / width;
    //float yCoord = z / height;

    if (constraints_count < 4)
        return float2(0, 0);

    float v_max = 0;
    float h = 0;
    float dist_min = 1000;
    float4x4 m_matrix = { -0.5,    1, -0.5,   0,
                           1.5, -2.5,    0,   1,
                          -1.5,    2,  0.5,   0,
                           0.5, -0.5,    0,   0 };
    for (int constraints_index = 0; constraints_index < constraints_count - 3; constraints_index++) // constraints_count - 3
    {
        for (int i = 0; i < 10; i++)
        {
            float t = i / 10.0;
            float4 t_vector = float4(t * t * t, t * t, t, 1);
            float4x4 g_matrix = { constraints[constraints_index].x, constraints[constraints_index + 1].x, constraints[constraints_index + 2].x, constraints[constraints_index + 3].x,
                                  constraints[constraints_index].y, constraints[constraints_index + 1].y, constraints[constraints_index + 2].y, constraints[constraints_index + 3].y, 
                                  constraints[constraints_index].z, constraints[constraints_index + 1].z, constraints[constraints_index + 2].z, constraints[constraints_index + 3].z, 
                                                                 1,                                    1,                                    1,                                    1 };
            float4 loc = mul(g_matrix, mul(m_matrix, t_vector));
            float2 bz = float2(loc.x, loc.z);
            //float2 xy = float2(xCoord, yCoord);
            float2 xz = float2(x, z);
            float dist = length(bz - xz);
            float v = 1 - (dist - 8.0) / 8.0;
            if (dist < 8.0) // 2 * 8 = road_width * (tex_size / piece_num)
                v = 1;
            else if (dist > 16.0)
                v = 0;
            if (v_max < v)
            {
                v_max = v;
            }
            if (dist_min > dist)
            {
                dist_min = dist;
                h = loc.y;
            }
        }
    }
    return float2(v_max, h);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float height = IDW(x + id.x * resolution, z + id.y * resolution) + bias_y;
    float2 road_constraint = renderConstraints(x + id.x * resolution, z + id.y * resolution); // x is dist, y is DEM height
    //float road_constraint = roadConstraint(x + id.x * resolution, z + id.y * resolution);
    //if (road_constraint.x > 0)
    height = (road_constraint.x) * road_constraint.y + (1 - road_constraint.x) * height;
    //    height = linearWeight(x + id.x * resolution, z + id.y * resolution);
    
    int height_int = int(height);
    float height_0 = (height_int / 64) / 64.0;
    float height_1 = (height_int % 64) / 64.0;
    float height_2 = height - height_int;
    Result[id.xy] = float4(road_constraint.x, height_0, height_1, height_2);
    Constraintsmap[id.xy] = float4(road_constraint.x, 0, 0, 1);
    //heights[id.x + id.y * 64] = height;
    //Result[id.xy] = float4(id.x / 768.0f, id.x / 768.0f, id.x / 768.0f, 1.0);
    progress[0] = 1;
}