// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float4 features[512];
int features_count;
float4 constraints[512];
int constraints_count;
//float height_base;
float x;
float z;
float resolution;

float getWeight(float d, float w)
{
    float f = pow(d, w);
    if (f < 0.000001)
        return 0.000001;
    return 1 / f;
}

float NNI(float x, float z)
{
    float dist_min = 1e6;
    float min_index = 0;
    for (int i = 0; i < features_count; i++)
    {
        float dist = sqrt(pow(features[i].x - x, 2) + pow(features[i].z - z, 2));
        if (features[i].w > -1 && dist < dist_min)
        {
            dist_min = dist;
            min_index = i;
        }
    }
    return features[min_index].y;
}

float linearWeight(float x, float z)
{
    float dist_min = 1e6;
    float min_index = 0;
    for (int i = 0; i < constraints_count; i++)
    {
        float dist = sqrt(pow(constraints[i].x - x, 2) + pow(constraints[i].z - z, 2));
        if (dist < dist_min)
        {
            dist_min = dist;
            min_index = i;
        }
    }
    
    if (min_index < constraints_count - 1)
    {
        float2 AB = float2(constraints[min_index + 1].x - constraints[min_index].x, constraints[min_index + 1].z - constraints[min_index].z);
        float2 AC = float2(x - constraints[min_index].x, z - constraints[min_index].z);
        float AB_AC = (AB.x * AC.x + AB.y * AC.y);
        if (AB_AC > 0)
        {
            float dist_a = sqrt(pow(constraints[min_index].x - x, 2) + pow(constraints[min_index].z - z, 2));
            float dist_b = sqrt(pow(constraints[min_index + 1].x - x, 2) + pow(constraints[min_index + 1].z - z, 2));
            return (constraints[min_index].y * dist_b + constraints[min_index + 1].y * dist_a) / (dist_a + dist_b);
        }
        else
        {
            if (min_index > 0)
            {
                float dist_a = sqrt(pow(constraints[min_index - 1].x - x, 2) + pow(constraints[min_index - 1].z - z, 2));
                float dist_b = sqrt(pow(constraints[min_index].x - x, 2) + pow(constraints[min_index].z - z, 2));
                return (constraints[min_index - 1].y * dist_b + constraints[min_index].y * dist_a) / (dist_a + dist_b);
            }
            else
            {
                return constraints[min_index].y;
            }
        }
    }
    else
    {
        return constraints[min_index].y;
    }
}

float IDW(float x, float z)
{
    float sum_up = 0.0;
    float sum_down = 0.0;
    for (int i = 0; i < features_count; i++)
    {
        float dist = sqrt(pow(features[i].x - x, 2) + pow(features[i].z - z, 2));
        if (pow(dist, 2) < 1e-6)
            return features[i].y;
        if (dist < 320.0)
        {
            sum_up += getWeight(dist, 2) * features[i].y;
            sum_down += getWeight(dist, 2);
        }
    }
    if (sum_down < 1e-6)
        sum_down = 1e-6;
    return sum_up / sum_down;
}

float roadConstraint(float x, float z)
{
    for (int i = 0; i < constraints_count - 1; i++)
    {
        float2 AB = float2(constraints[i + 1].x - constraints[i].x, constraints[i + 1].z - constraints[i].z);
        float2 AC = float2(x - constraints[i].x, z - constraints[i].z);
        float2 BC = float2(x - constraints[i + 1].x, z - constraints[i + 1].z);

        float AB_BC = (AB.x * BC.x + AB.y * BC.y);
        float AB_AC = (AB.x * AC.x + AB.y * AC.y);

        float distance = 1e6;

        if (AB_BC < 0 && AB_AC > 0)
        {
            // Finding the perpendicular distance
            double x1 = AB.x;
            double y1 = AB.y;
            double x2 = AC.x;
            double y2 = AC.y;
            double mod = sqrt(x1 * x1 + y1 * y1);
            distance = abs(x1 * y2 - y1 * x2) / mod;
        }

        if (distance < 16.0f)
        {
            return (i + 1) / 128.0;
        }
    }
    for (int i = 0; i < constraints_count; i++)
    {
        float dist = sqrt(pow(constraints[i].x - x, 2) + pow(constraints[i].z - z, 2));
        if (dist < 16.0f)
        {
            return (i + 1) / 128.0;
        }
    }
    return 0.0f;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float height = IDW(x + id.x * resolution, z + id.y * resolution);
    float road_constraint = roadConstraint(x + id.x * resolution, z + id.y * resolution);
    if (road_constraint > 0)
        height = linearWeight(x + id.x * resolution, z + id.y * resolution);
    /*float height = IDW(x + id.x, z + id.y);
    float road_constraint = roadConstraint(x + id.x, z + id.y);
    if (road_constraint > 0)
        height = linearWeight(x + id.x, z + id.y);*/
        //height = NNI(x + id.x, z + id.y);
    Result[id.xy] = float4(height / 900, road_constraint, height / 900, 1.0);
    //Result[id.xy] = float4(id.x / 768.0f, id.x / 768.0f, id.x / 768.0f, 1.0);
}